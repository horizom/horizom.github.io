(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{128:function(e,t,a){"use strict";a.d(t,"a",(function(){return b})),a.d(t,"b",(function(){return h}));var n=a(0),o=a.n(n);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var p=o.a.createContext({}),u=function(e){var t=o.a.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},b=function(e){var t=u(e.components);return o.a.createElement(p.Provider,{value:t},e.children)},s={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},d=o.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,l=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),b=u(a),d=n,h=b["".concat(l,".").concat(d)]||b[d]||s[d]||r;return a?o.a.createElement(h,i(i({ref:t},p),{},{components:a})):o.a.createElement(h,i({ref:t},p))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,l=new Array(r);l[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:n,l[1]=i;for(var p=2;p<r;p++)l[p]=a[p];return o.a.createElement.apply(null,l)}return o.a.createElement.apply(null,a)}d.displayName="MDXCreateElement"},97:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return l})),a.d(t,"metadata",(function(){return i})),a.d(t,"toc",(function(){return c})),a.d(t,"default",(function(){return u}));var n=a(3),o=a(8),r=(a(0),a(128)),l={},i={unversionedId:"framework/routing/defining-routes",id:"framework/routing/defining-routes",isDocsHomePage:!1,title:"Defining Routes",description:"Every time you add a route to the Map, you get back a Route object. The Route object is pretty powerful, and allows you to define a wide range of matching conditions. All of the Route methods are fluent, so you can chain them together.",source:"@site/docs/framework/routing/defining-routes.md",sourceDirName:"framework/routing",slug:"/framework/routing/defining-routes",permalink:"/docs/framework/routing/defining-routes",editUrl:"https://github.com/horizom/docs/edit/master/docs/framework/routing/defining-routes.md",version:"current",frontMatter:{},sidebar:"framework",previous:{title:"Attaching Route Groups",permalink:"/docs/framework/routing/attaching-route-groups"}},c=[{value:"Placeholder Tokens and Default Values",id:"placeholder-tokens-and-default-values",children:[]},{value:"Custom Placeholder Token Matching",id:"custom-placeholder-token-matching",children:[]},{value:"Optional Placeholder Tokens",id:"optional-placeholder-tokens",children:[]},{value:"Wildcard Attributes",id:"wildcard-attributes",children:[]},{value:"Host Matching",id:"host-matching",children:[]},{value:"Accept Headers",id:"accept-headers",children:[]},{value:"Multiple HTTP Verbs",id:"multiple-http-verbs",children:[]},{value:"Secure Protocols",id:"secure-protocols",children:[]},{value:"Non-Routable Routes",id:"non-routable-routes",children:[]},{value:"Authentication",id:"authentication",children:[]},{value:"Custom Extras",id:"custom-extras",children:[]},{value:"Route-Specific Matching Logic",id:"route-specific-matching-logic",children:[]},{value:"Default Map Route Specifications",id:"default-map-route-specifications",children:[]}],p={toc:c};function u(e){var t=e.components,a=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(n.a)({},p,a,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Every time you add a route to the ",Object(r.b)("em",{parentName:"p"},"Map"),", you get back a ",Object(r.b)("em",{parentName:"p"},"Route")," object. The ",Object(r.b)("em",{parentName:"p"},"Route")," object is pretty powerful, and allows you to define a wide range of matching conditions. All of the ",Object(r.b)("em",{parentName:"p"},"Route")," methods are fluent, so you can chain them together."),Object(r.b)("h3",{id:"placeholder-tokens-and-default-values"},"Placeholder Tokens and Default Values"),Object(r.b)("p",null,"When you add a ",Object(r.b)("inlineCode",{parentName:"p"},"{token}")," placeholder in the path, it uses a default regular expression of ",Object(r.b)("inlineCode",{parentName:"p"},"([^/]+)"),". Essentially, this matches everything except a slash, which of course indicates the next path segment."),Object(r.b)("p",null,"To define custom regular expressions for placeholder tokens, use the ",Object(r.b)("inlineCode",{parentName:"p"},"tokens()")," method."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-php"},"<?php\n$map->get('blog.read', '/blog/{id}')\n    ->tokens(['id' => '\\d+'])\n?>\n")),Object(r.b)("p",null,"The ",Object(r.b)("em",{parentName:"p"},"Route")," object does not predefine any tokens for you. One that you may find useful is a ",Object(r.b)("inlineCode",{parentName:"p"},"{format}")," token, to specify an optional dot-format extension at the end of a file name:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-php"},"<?php\n$map->get('blog.read', '/blog/{id}{format}')\n    ->tokens([\n        'id' => '\\d+',\n        'format' => '(\\.[^/]+)?',\n    ]);\n?>\n")),Object(r.b)("p",null,"If no default value is specified for a placeholder token, the corresponding attribute value will be ",Object(r.b)("inlineCode",{parentName:"p"},"null"),". To set your own default values, call the ",Object(r.b)("inlineCode",{parentName:"p"},"defaults()")," method."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-php"},"<?php\n$map->post('blog.archive', '/blog/{id}{format}')\n    ->defaults([\n        'format' => '.html',\n    ]);\n?>\n")),Object(r.b)("h3",{id:"custom-placeholder-token-matching"},"Custom Placeholder Token Matching"),Object(r.b)("p",null,"Sometimes it's useful to be able to do custom matching of placeholder tokens."),Object(r.b)("p",null,"To define a custom callback for placeholder tokens, use the ",Object(r.b)("inlineCode",{parentName:"p"},"tokens()")," method."),Object(r.b)("p",null,"The following will verify that date is a valid DateTime format:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-php"},"<?php\n$map->get('/calendar/from/{date}')\n    ->tokens([\n        'date' => function ($date, $route, $request) {\n            try {\n                new \\DateTime($date);\n                return true;\n            } catch(\\Exception $e) {\n                return false;\n            }\n        }\n    ]);\n")),Object(r.b)("h3",{id:"optional-placeholder-tokens"},"Optional Placeholder Tokens"),Object(r.b)("p",null,"Sometimes it is useful to have a route with optional placeholder tokens for attributes. None, some, or all of the optional values may be present, and the route will still match."),Object(r.b)("p",null,"To specify optional attributes, use the notation ",Object(r.b)("inlineCode",{parentName:"p"},"{/attribute1,attribute2,attribute3}")," in the path. For example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-php"},"<?php\n$map->get('archive', '/archive{/year,month,day}')\n    ->tokens([\n        'year' => '\\d{4}',\n        'month' => '\\d{2}',\n        'day' => '\\d{2}',\n    ]);\n?>\n")),Object(r.b)("p",null,"Note that the leading slash separator is ",Object(r.b)("em",{parentName:"p"},"inside")," the placeholder token, not outside."),Object(r.b)("p",null,"With that, the following paths will all match the 'archive' route, and set the attribute values accordingly:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"/archive            : ['year' => null,   'month' => null, 'day' = null]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"/archive/1979       : ['year' => '1979', 'month' => null, 'day' = null]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"/archive/1979/11    : ['year' => '1979', 'month' => '11', 'day' = null]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"/archive/1979/11/07 : ['year' => '1979', 'month' => '11', 'day' = '07']"))),Object(r.b)("p",null,"Optional attributes are ",Object(r.b)("em",{parentName:"p"},"sequentially"),' optional. This means that, in the above example, you cannot have a "day" without a "month", and you cannot have a "month" without a "year".'),Object(r.b)("p",null,"You can have only one set of optional attributes in a route path."),Object(r.b)("p",null,"Optional attributes belong at the end of a route path. Placing them elsewhere may result in unexpected behavior."),Object(r.b)("h3",{id:"wildcard-attributes"},"Wildcard Attributes"),Object(r.b)("p",null,"Sometimes it is useful to allow the trailing part of the path be anything at all. To allow arbitrary trailing path segments on a route, call the ",Object(r.b)("inlineCode",{parentName:"p"},"wildcard()")," method. This will let you specify the attribute name under which the arbitrary trailing values will be stored."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-php"},"<?php\n$map->get('wild', '/wild')\n    ->wildcard('card');\n?>\n")),Object(r.b)("p",null,"All slash-separated path segments after the ",Object(r.b)("inlineCode",{parentName:"p"},"{id}")," will be captured as an array in the in wildcard attribute. For example:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"/wild             : ['card' => []]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"/wild/foo         : ['card' => ['foo']]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"/wild/foo/bar     : ['card' => ['foo', 'bar']]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"/wild/foo/bar/baz : ['card' => ['foo', 'bar', 'baz']]"))),Object(r.b)("h3",{id:"host-matching"},"Host Matching"),Object(r.b)("p",null,"You can limit a route to specific hosts with the ",Object(r.b)("inlineCode",{parentName:"p"},"host()")," method and a regular expression. The following example will only match when the request is on ",Object(r.b)("inlineCode",{parentName:"p"},"example.com")," domain:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-php"},"<?php\n$map->get('blog.browse', '/blog')\n    ->host('example.com');\n?>\n")),Object(r.b)("p",null,"(","Dots in the regular expression will automatically be escaped for you.",")"),Object(r.b)("p",null,"You can use placeholder tokens and default values in the host specification, and capture those values into route attributes. The following matches ",Object(r.b)("inlineCode",{parentName:"p"},"*.example.com")," and captures the subdomain value as a route attribute:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-php"},"<?php\n$map->get('blog.browse', '/blog')\n    ->host('{subdomain}.?example.com');\n?>\n")),Object(r.b)("h3",{id:"accept-headers"},"Accept Headers"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"accepts()")," method adds to a list of content types that the route handler can be expected to return."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-php"},"<?php\n$map->get('blog.browse', '/blog')\n    ->accepts([\n        'application/json',\n        'application/xml',\n        'text/csv',\n    ]);\n?>\n")),Object(r.b)("p",null,"Note that this is ",Object(r.b)("em",{parentName:"p"},"not")," a content negotiation method. It is only a pro-forma check to see if one of the specified types is present in the ",Object(r.b)("inlineCode",{parentName:"p"},"Accept")," header with a non-zero ",Object(r.b)("inlineCode",{parentName:"p"},"q")," value. THe handler, or some other layer, should perform content negotation proper."),Object(r.b)("h3",{id:"multiple-http-verbs"},"Multiple HTTP Verbs"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"allows()")," method adds to the allowed HTTP verbs for the route."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-php"},"<?php\n$map->post('blog.edit', '/blog/{id}')\n    ->allows(['PATCH', 'PUT'])\n?>\n")),Object(r.b)("h3",{id:"secure-protocols"},"Secure Protocols"),Object(r.b)("p",null,"You can use the ",Object(r.b)("inlineCode",{parentName:"p"},"secure()")," method to specify that a route should only match a secure protcol. ","(","Specifically, ",Object(r.b)("inlineCode",{parentName:"p"},"$_SERVER['HTTPS']")," must be on, or the request must be on port 443.",")"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-php"},"<?php\n$map->post('blog.edit', '/blog/{id}')\n    ->secure();\n?>\n")),Object(r.b)("p",null,"You can call ",Object(r.b)("inlineCode",{parentName:"p"},"secure(false)")," to limit the route to only non-secure protocols. Calling ",Object(r.b)("inlineCode",{parentName:"p"},"secure(null)")," causes the route to ignore the protocol security."),Object(r.b)("h3",{id:"non-routable-routes"},"Non-Routable Routes"),Object(r.b)("p",null,"Sometimes you will want to have a route in the ",Object(r.b)("em",{parentName:"p"},"Map")," that is used only for generating paths, and not for matching to handlers. In this case, you can call ",Object(r.b)("inlineCode",{parentName:"p"},"isRoutable(false)"),". ","(","This is rare but useful.",")"),Object(r.b)("h3",{id:"authentication"},"Authentication"),Object(r.b)("p",null,"Each route instance has a special-purpose method and property, ",Object(r.b)("inlineCode",{parentName:"p"},"auth()")," and ",Object(r.b)("inlineCode",{parentName:"p"},"$auth"),", for you to store authentication/authorization values. These values are entirely arbitrary, and are best used with custom matching rules of your own design."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-php"},"<?php\n$map->post('blog.admin', '/blog/admin')\n    ->auth([\n        'isAdmin' => true,\n    ]);\n?>\n")),Object(r.b)("h3",{id:"custom-extras"},"Custom Extras"),Object(r.b)("p",null,"Other, custom data about the route can be stored using the ",Object(r.b)("inlineCode",{parentName:"p"},"extras()")," method. Pass an array of key-value pairs and it will be merged with any other custom data already stored."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-php"},"<?php\n$map->post('blog.other', '/blog/other')\n    ->extras([\n        'foo' => true,\n        'bar' => false,\n    ]);\n?>\n")),Object(r.b)("p",null,"You can then use these extra values in your own custom matching rules."),Object(r.b)("h3",{id:"route-specific-matching-logic"},"Route-Specific Matching Logic"),Object(r.b)("p",null,"If you need a special matching logic on an individual ",Object(r.b)("em",{parentName:"p"},"Route"),", you can use the ",Object(r.b)("inlineCode",{parentName:"p"},"special()")," method to add a callable to the ",Object(r.b)("em",{parentName:"p"},"Route")," for matching. The method should return a boolean to indicate if the ",Object(r.b)("em",{parentName:"p"},"Route")," is a match or not."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-php"},"<?php\n$map->get('foo', '/foo/bar/{baz}')\n    ->special(function ($request, $route) {\n        if ($request->getHeader('Foo') == 'bar') {\n            $route->extras(['foo' => true]);\n            return true;\n        }\n        return false;\n    }\n})\n?>\n")),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"N.b.: You can also create a ",Object(r.b)("em",{parentName:"p"},"Rule")," that applies to all routes;")),Object(r.b)("h3",{id:"default-map-route-specifications"},"Default Map Route Specifications"),Object(r.b)("p",null,"You can call any of the above ",Object(r.b)("em",{parentName:"p"},"Route")," methods on the ",Object(r.b)("em",{parentName:"p"},"Map"),". When you do so, the ",Object(r.b)("em",{parentName:"p"},"Map")," will then use those as the defaults for every route you add thereafter. This is useful for defining a base set of placeholder token expressions, default values, and so on."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-php"},"<?php\n// define defaults for all routes added hereafter\n$map->tokens([\n    'id' => '\\d+',\n    'format' => '(\\.[^/]+)?',\n])->defaults([\n    'format' => '.json',\n])->host(\n    '{subdomain}.?example.com'\n)->accepts([\n    'application/json',\n    'application/xml',\n    'text/html',\n]);\n\n// each added route now uses the map defaults\n$map->get('blog.browse', '/blog');\n$map->get('blog.read', '/blog/{id}{format}');\n$map->patch('blog.edit', '/blog/{id}');\n$map->post('blog.add', '/blog');\n$map->delete('blog.delete', '/blog/{id}');\n?>\n")))}u.isMDXComponent=!0}}]);